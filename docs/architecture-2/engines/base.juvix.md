---
search:
exclude: false
tags:
- engine
- engine-type
- Juvix
---


??? info "Juvix imports"

    ```juvix
    module architecture-2.engines.base;
    import architecture-2.engines.basic-types open;
    ```


# Engine Family Types

## Core Types and Concepts

This page highlights the essential types and concepts needed to define an engine
family in the Anoma Specification, specifically focusing on writing these
families in Juvix. Please refer to the [[Engines in Anoma]] page for a better
overview and motivation of the concept of engines for Anoma.

Each engine family must declare specific components essential to its purpose.
For Anoma specifications, these components include:

- **Local Environment**: This serves as the execution context for engines.
  In addition to the local state, the local
  environment encompasses elements such as the mailbox cluster owned by an
  engine instance and a set of acquaintancesâ€”other engine instances known to the
  current one that can interact with it.

- **Guarded Action**: Engines are not merely storage units; they also process
  information and communicate with other engine instances through messages.
  Their behavior is defined by their guarded actions, which are rules or
  state-transition functions accompanied by specific conditions allowing their
  execution when messages are received.

So, let's introduce the type for each of these components.


### Local Environment

The local environment encompasses static information for engine instances in the
following categories:

- A global reference, name, for the engine instance.
- Local state.
- Mailbox cluster, which is a map of mailbox IDs to mailboxes. <!-- TODO, rethink this type, or describe it differently. -->
- A set of names of acquainted engine instances. It is implicit that the engine
  instance is acquainted with itself, so no need to include its own name.
- A list of timers that have been set.

This data is encapsulated in the `LocalEnvironment` type. The `LocalEnvironment` 
type is parameterised by two types: `LocalStateType` and 
`MessageType` representing the local state and message types, respectively.

```juvix
type LocalEnvironment (LocalStateType : Type) (MessageType : Type) := 
  mkLocalEnvironment {
      engineRef : Name ;
      localState : LocalStateType;
      mailboxCluster : Map MailboxID (Mailbox MessageType); 
      acquaintances : Set Name;
      timers : List Timer;
};
```

For short, we will use the type parameters `S` and `M` to represent 
the type of the local state and message types, respectively.

### Engine Behaviours

In line with the actor model, each engine processes only one message at a time.
The behavior of an engine is specified by a set of _guarded actions_, which define
the transitions an engine can make from one state to another based on specific
conditions.

Guarded actions are represented by the type `GuardedAction`, which encapsulates
the following components:
 
- A guard function of type `Trigger -> LocalEnvironment S M -> Maybe T`, where
  the trigger of type `Trigger` is used to capture the message receveid. This
  trigger can include the received message or timers that have elapsed during
  the engine's operation. 

- A state transition function of type `StateTransition S T`, where `S`
  represents the local state type and `T` represents the message type.

So, let us first define the type for state transitions, split into 
`StateTransitionInput` and `StateTransitionResult` types.

```juvix
StateTransition (S M T : Type) : Type := StateTransitionInput S M T -> StateTransitionResult S M;
```

A state transition function takes the following arguments:

- The input of type `T` generated by running the corresponding guard function, if any.
- The engine instance's local environment.
- The time at which the state transition is triggered.

These arguments are encapsulated in the `StateTransitionInput` record type below.

```juvix
type StateTransitionInput (S M T : Type)
  := mkStateTransitionInput {
      action : T; 
      env : LocalEnvironment S M;
      time : Time;
};
```

The `StateTransitionResult` type defines the results produced by a state
transition function. When executing such a function, the engine instance will:

- Update its local state.
- Queue messages for transmission.
- Set timers.
- Define new engine instances to be created.

To create these new engine instances, we need to specify the following data:

- The engine family type.
- The name of the new engine instance.
- The initial state of the engine instance.

This information is encapsulated within the `EngineInstance` type defined
further below.

We can now define the `StateTransitionResult` type as follows:

```juvix
type StateTransitionResult (S M : Type)
  := mkStateTransitionResult {
      newEnv : LocalEnvironment S M;
      producedMessages : {T : Type} -> Mailbox T;
      spawnedEngines : List ({eS eM : Type} -> EngineInstance eS eM);
      timers : List Timer;
};
```

#### Guarded Actions

To recap, a guarded action consists of a _guard_ and an _transition_. The guard
is a function that evaluates conditions on the engine's local environment to
decide if the action should be executed. This guard function has as input the
trigger that caused the action to be evaluated, and the local environment of the
engine instance to determine if the condition is met. The state transition is a
function that updates the local environment and may include additional effects,
such as setting timers, messages, and spawning new engines.


<!-- 
TODO:
The following should be a record type for better readability. However, in Juvix
v0.6.3 is not possible due to
https://github.com/anoma/juvix/issues/2247. -->
```juvix
type GuardedAction (S M T : Type) := mkGuardedAction {
   act : 
    Pair
      ({A : Type} -> Trigger A -> LocalEnvironment S M -> Maybe T)
      (StateTransition S M T)
};
```

??? info "Notation: Curly braces in guard and action's type signature"

    The curly braces notation used in the type signature of the `action` constructor
    indicates that the type argument `T` can be omitted, as it is inferred from the
    return type.

    Ideally, type `T` should be an implicit field of `GuardedAction`, indicating
    that the action takes input from the guard's evaluation when satisfied. However,
    this is not feasible in Juvix at the moment.

??? info "On the type signature of the guard function"

    In principle, a guard is a predicate that evaluates the current state and local
    environment of the engine instance, that is, a function returning a boolean. 
    
    ```
    boolean-guard : Trigger -> LocalEnvironment S M -> Bool;
    ```

    However, as a design choice, guards will return additional data of type `T` from
    the local environment if the condition is met. So, if the guard is satisfied,
    this data (of type `T`) will be passed to the action function; otherwise, that
    is, if the guard is not satisfied, no data is returned. This value of type `T` is
    reflected as one of the fields for `StateTransitionInput`.

## Engine Families and Instances

The `EngineFamily` type encapsulates the concept of engines within Anoma. As defined,
it clears up that engines are essentially a collection of guarded state-transition
functions. Our type for these families is parameterised by a type for their local states,
and a type for their messages.

```juvix
type EngineFamily (LocalStateType : Type) (MessageType : Type) := mkEngineFamily {
  actions : List ({T : Type} -> GuardedAction LocalStateType MessageType T);
};
```

Additionally, we define the `EngineInstance` type, which represents an instance
of an engine within a family. Each engine instance is associated with a specific
name and a family of engines, plus a declaration its own local state; more
specifically, each instance possesses its own execution context.

```juvix
type EngineInstance (S M : Type):= mkEngineInstance {
  name : Name;
  family : EngineFamily S M;
  initState : LocalEnvironment S M;
};
```

!!! example

    For example, to define an engine family for voting:

    - `LocalStateType` could be a record with fields like `votes`, `voters`, and `results`.
    - The message type might be a coproduct of `Vote` and `Result`.
    - The guarded actions may include actions like:
        - `storeVote` to store a vote in the local state,
        - `computeResult` to compute the result of the election, and
        - `announceResult` to send the result to some other engine instances.

    In this example, engine instances may vary (e.g., different elections or
    voters), but the voting systems will operate identically given the same
    initial state. This ensures consistent behavior across all engine instances
    within the same family.

!!! info

    In the `EngineFamily` type above, `List` is used because if multiple guards are 
    satisfied, we assume that their corresponding actions are executed according to
    their index in the list, defining the priority of each (guarded) action. This behaviour
    may, in principle, change in the future.
