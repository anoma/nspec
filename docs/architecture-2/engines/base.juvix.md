---
search:
exclude: false
tags:
- engine
- engine-type
- Juvix
---


??? info "Juvix imports"

    ```juvix
    module architecture-2.engines.base;
    import architecture-2.engines.basic-types open;
    ```


# Engine Family Types

## Core Types and Concepts

This page highlights the essential types and concepts needed to define an engine
family in the Anoma Specification, specifically focusing on writing these
families in Juvix. Please refer to the [[Engines in Anoma]] page for a better
overview and motivation of the concept of engines for Anoma.

Each engine family must declare specific components essential to its purpose.
For Anoma specifications, these components include:

- **Local Environment**: This serves as the execution context for engines.
  In addition to the local state, the local
  environment encompasses elements such as the mailbox cluster owned by an
  engine instance and a set of acquaintancesâ€”other engine instances known to the
  current one that can interact with it.

- **Guarded Action**: Engines are not merely storage units; they also process
  information and communicate with other engine instances through messages.
  Their behavior is defined by their guarded actions, which are rules or
  state-transition functions accompanied by specific conditions allowing their
  execution when messages are received.

So, let's introduce the type for each of these components.


### Local Environment

The local environment encompasses static information for engine instances in the
following categories:

- A global reference, name, for the engine instance.
- Local state.
- Mailbox cluster, which is a map of mailbox IDs to mailboxes. <!-- TODO, rethink this type, or describe it differently. -->
- A set of names of acquainted engine instances. It is implicit that the engine
  instance is acquainted with itself, so no need to include its own name.
- A list of timers that have been set.

This data is encapsulated in the `LocalEnvironment` type. The `LocalEnvironment` 
type is parameterised by two types: `LocalStateType` and 
`IncomingMessageType` representing the local state and the type of message
the engine read, respectively.

```juvix
type LocalEnvironment (LocalStateType : Type) (IncomingMessageType : Type) := 
  mkLocalEnvironment {
      engineRef : Name ;
      localState : LocalStateType;
      mailboxCluster : Map MailboxID (Mailbox IncomingMessageType); 
      acquaintances : Set Name;
      timers : List Timer;
};
```

For short, we will use the type parameters `S` and `I` to represent 
the type of the local state and incoming message types, respectively.

### Engine Behaviours

In line with the actor model, each engine processes only one message at a time.
The behavior of an engine is specified by a set of _guarded actions_, which define
the transitions an engine can make from one state to another based on specific
conditions.

Guarded actions are represented by the type `GuardedAction`, which encapsulates
the following components:
 
- A guard function of type `Trigger -> LocalEnvironment S I -> Maybe R`, where
  the trigger of type `Trigger` is a term that captures the message receveid. This
  trigger can include the received message or timers that have elapsed during
  the engine's operation. Guards return data of type `R` if the condition is met.
  That data feeds as input for the actual state transition function.

- A state transition function of type `StateTransition S I R O`, where the new
  type variable `O` represents the outgoing type of messages. 

#### State Transition Functions

Below, we define the type for state transition functions. These functions are
parametrised by the types for local state, incoming messages, the data returned
by the guard function, and outgoing messages.

```juvix
StateTransition (S I R O : Type) : Type := StateTransitionInput S I R -> StateTransitionResult S I R O;
```

In the type declaration above, we have that a state transition function takes the following inputs:

- The input of type `R` generated by running the corresponding guard function, if any.
- The local environment of the engine instance.
- The time at which the state transition is executed.

These arguments are encapsulated in the `StateTransitionInput S I R` record type below.

```juvix
type StateTransitionInput (S I R : Type)
  := mkStateTransitionInput {
      action : R; 
      env : LocalEnvironment S I;
      time : Time;
};
```

The `StateTransitionResult S I R O` type defines the results produced by a state
transition function. When executing such a function, the engine instance can:

- Update its local state.
- Set messages to be sent to other engine instances.
- Set timers.
- Define new engine instances to be created.

    ??? info "On creating new engine instances"
          
        To create these new engine instances, we need to specify the following data:

        - The engine family type.
        - The name of the new engine instance.
        - The initial state of the engine instance.

        This information is encapsulated within the `EngineInstance` type defined
        further below.

```juvix

type StateTransitionResult (S I R O : Type) := mkStateTransitionResult {
    newEnv : LocalEnvironment S I;
    producedMessages : List (EnvelopedMessage O);
    spawnedEngines : List ({eS eI eR eO : Type} -> Engine eS eI eR eO);
    -- TODO: Here, would be really nice if we have sigma types, or some form of it that allows
    -- us to define, for example, the type for enveloped messages for all possible types.
    timers : List Timer;
};
```


#### Guarded Actions

To recap, a guarded action consists of a _guard_ and an _transition_. The guard
is a function that evaluates conditions on the engine's local environment to
decide if the action should be executed. This guard function has as input the
trigger that caused the action to be evaluated, and the local environment of the
engine instance to determine if the condition is met. The state transition is a
function that updates the local environment and may include additional effects,
such as setting messages to be sent or creating new engine instances.


```juvix
type GuardedAction (S I R O : Type) := mkGuardedAction {
   guard : Trigger I -> LocalEnvironment S I -> Maybe R;
   action : StateTransition S I R O
};
```

??? info "On the type signature of the guard function"

    In principle, a guard is a predicate that evaluates the current state and local
    environment of the engine instance, that is, a function returning a boolean. 
    
    ```
    boolean-guard : Trigger I -> LocalEnvironment S I -> Bool;
    ```

    However, as a design choice, guards will return additional data of type `R` from
    the local environment if the condition is met. So, if the guard is satisfied,
    this data (of type `R`) is assumed to be passed to the action function; otherwise, that
    is, if the guard is not satisfied, no data is returned. 

## Engine Families and Instances

The `EngineFamily` type encapsulates the concept of engines within Anoma. As defined,
it clears up that engines are essentially a collection of guarded state-transition
functions. Our type for these families is parameterised by a type for their local states,
a type for their incoming messages, a type for returned data by the guard functions, and
a type for outgoing messages.

```juvix
type EngineFamily (S I R O : Type) := mkEngineFamily {
  actions : List (GuardedAction S I R O);
};
```

??? info "On the use of `List` in `EngineFamily`"

    In the `EngineFamily` type, we used `List` not just for
    convenience but also because we have not yet established a way to compare or
    sort guarded actions, guards, and state transition functions. Additionally,
    using `List` specifies the order in which the guarded actions will execute when
    multiple guards are met. This behavior might change in the future.

Additionally, we define the `Engine` type, which represents an engine within a family.
A term of this `Engine` type is referred to as an engine instance. Each engine instance
is associated with a specific name and a family of engines, plus a declaration of its own
execution context.

```juvix
type Engine (S I R O : Type):= mkEngine {
  name : Name;
  family : EngineFamily S I R O;
  initEnv : LocalEnvironment S I;
};
```

!!! example

    As an example, we could define an engine family for voting:

    - `LocalStateType` could be a record with fields like `votes`, `voters`, and `results`.
    - The incomming message type might be a coproduct of `Vote` and `Result`.
    - The guarded actions may include actions like:
        - `storeVote` to store a vote in the local state,
        - `computeResult` to compute the result of the election, and
        - `announceResult` to send the result to some other engine instances.

    With each different election or kind of voters, we obtain a new engine instance,
    while the underlining voting system, the voting engine family, remains the same.

